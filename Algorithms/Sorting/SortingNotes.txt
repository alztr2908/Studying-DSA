Bubble Sort
    for i in 0..nums:
        for j in 0..len(nums)-i-1:
            swap(nums[j], nums[j+1]) if nums[j] > n
    
    second loop has a dynamic range of len(nums)-i-1: 
        minus i because at the end of every iteration, 
        the last place of nums is already sorted so no
        need to access it

        minus 1 because we are comparing nums[j] and nums[j+1]
        if there is no minus 1 there then it will result to index 
        out of bounds when i = len(nums)

Insertion sort
    for i in 0..nums_length - 1:
        j = i 

        while nums[j] > nums[j+1] and j >= 0:
            swap(nums[j], nums[j+1])
            j-=1
    
    first loop is not until nums_length because when i = nums_length,
    j+1 will be out of bounds

    j>=0 on the second loop because nums[-i] is not valid

Selection sort
    min_value = inf
    index_min = 0

    for i in 0..nums:
        for j in i..nums:
            if nums[j] < min_value:
                min_value = nums[j]
                index_min = 0

            swap(nums[index_min],nums[j])